from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer
from app.routers import checkin_router, ranking_router, user_router
from app.db.database import user_collection, checkin_collection, ranking_collection
from pymongo import ASCENDING

app = FastAPI(
    title="Squad Atendimentos - Treinamento Cognitivo",
    version="1.0",
    contact={"brubsmarcelle2022@gmail.com": "Brubs Marcelle"},
    description="API para gamifica√ß√£o de check-ins di√°rios com ranking semanal.",
    docs_url="/swagger",
    redoc_url=None,
    # Configura√ß√£o OAuth2 para Swagger
    swagger_ui_oauth2_redirect_url="/docs/oauth2-redirect",
    swagger_ui_init_oauth={
        "usePkceWithAuthorizationCodeGrant": True,
    }
)

# Configura√ß√£o CORS - Otimizada para autentica√ß√£o
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Em produ√ß√£o, especifique os dom√≠nios exatos
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "PATCH"],
    allow_headers=[
        "*",
        "Accept",
        "Accept-Language",
        "Content-Language", 
        "Content-Type",
        "Authorization",
        "WWW-Authenticate",
        "X-Requested-With",
        "Origin",
        "Access-Control-Request-Method",
        "Access-Control-Request-Headers",
    ],
    expose_headers=[
        "WWW-Authenticate",
        "Authorization"
    ]
)

# Middleware otimizado para debugging (apenas endpoints cr√≠ticos)
@app.middleware("http")
async def optimized_logging_middleware(request, call_next):
    import time
    
    # Apenas log detalhado para endpoints de auth
    is_auth_endpoint = request.url.path in ["/login", "/token", "/users"]
    
    if is_auth_endpoint:
        start_time = time.time()
        print(f"\nüîê AUTH REQUEST: {request.method} {request.url.path}")
        
        # Headers importantes apenas
        auth_header = request.headers.get('authorization', 'None')
        content_type = request.headers.get('content-type', 'None')
        print(f"   üìÑ Content-Type: {content_type}")
        print(f"   üîë Authorization: {'Present' if auth_header != 'None' else 'None'}")
        
        try:
            response = await call_next(request)
            process_time = time.time() - start_time
            
            status_emoji = "‚úÖ" if response.status_code < 400 else "‚ùå"
            print(f"   {status_emoji} Response: {response.status_code} ({process_time:.3f}s)")
            
            return response
        except Exception as e:
            process_time = time.time() - start_time
            print(f"   ‚ùå Error: {type(e).__name__} ({process_time:.3f}s)")
            raise
    else:
        # Para outros endpoints, apenas executa sem logging detalhado
        return await call_next(request)
@app.on_event("startup")
async def startup_db_client():
    """Cria √≠ndices e verifica integridade do banco de dados no startup"""
    try:
        print("\nüöÄ Iniciando configura√ß√£o do banco de dados...")
        
        # Importar as fun√ß√µes de verifica√ß√£o
        from app.db.database import check_database_health, fix_username_inconsistencies
        
        # Criar √≠ndices para otimizar performance das consultas
        await user_collection.create_index([("username", ASCENDING)], unique=True)
        print("‚úÖ √çndice de username criado com sucesso")
        
        # √çndice para checkins por user_id e timestamp (otimiza verifica√ß√µes de checkin)
        await checkin_collection.create_index([("user_id", ASCENDING), ("timestamp", ASCENDING)])
        print("‚úÖ √çndice de checkins criado com sucesso")
        
        # √çndice para rankings por user_id e week_id
        await ranking_collection.create_index([("user_id", ASCENDING), ("week_id", ASCENDING)])
        print("‚úÖ √çndice de rankings criado com sucesso")
        
        # Verificar sa√∫de do banco
        health = await check_database_health()
        
        # Corrigir inconsist√™ncias se houver dados
        if health.get("users", 0) > 0:
            await fix_username_inconsistencies()
        
        print("üéâ Banco de dados configurado e verificado com sucesso!\n")
        
    except Exception as e:
        print(f"‚ö†Ô∏è Aviso durante configura√ß√£o do banco: {e}")
        # N√£o falhar o startup por causa de problemas de banco
        pass

app.include_router(user_router.router)
app.include_router(checkin_router.router)
app.include_router(ranking_router.router)


@app.get("/healthcheck", summary="Verificar sa√∫de do sistema")
async def healthcheck():
    """
    Endpoint para verificar a sa√∫de do sistema e banco de dados.
    
    Returns:
        dict: Status de sa√∫de do sistema
        
    Raises:
        HTTPException: Erro na verifica√ß√£o de sa√∫de
    """
    from app.utils.logging import system_logger
    from app.db.database import check_database_health
    from datetime import datetime
    from app.services.logic import SAO_PAULO_TZ
    
    system_logger.info("üè• Verificando sa√∫de do sistema")
    
    try:
        # Verificar sa√∫de do banco
        db_health = await check_database_health()
        
        # Informa√ß√µes do sistema
        current_time = datetime.now(SAO_PAULO_TZ)
        today = current_time.date()
        week_id = f"{today.year}-W{today.isocalendar()[1]}"
        
        health_data = {
            "status": "healthy",
            "timestamp": current_time.isoformat(),
            "current_date": today.isoformat(),
            "current_week": week_id,
            "database": db_health,
            "timezone": "America/Sao_Paulo (UTC-3)"
        }
        
        system_logger.info(
            "‚úÖ Sistema saud√°vel",
            {"database_status": db_health.get("status", "unknown")}
        )
        
        return health_data
        
    except Exception as e:
        system_logger.error("Erro na verifica√ß√£o de sa√∫de", error=e)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Health check failed: {str(e)}"
        )


@app.get("/health", summary="Health check endpoint")
async def health():
    """
    Endpoint de health check padr√£o para containers Docker.
    
    Returns:
        dict: Status de sa√∫de do sistema
    """
    return await healthcheck()

